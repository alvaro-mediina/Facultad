# üíª Te√≥rico de Sistemas Operativos üíæ

En este archivo encontrar√°s un resumen o algunas ideas sobre el libro OSTEP (Operating Systems: Three Easy Pieces) y otros temas relacionados con sistemas operativos.

Como la materia se divide en 3 partes, tambi√©n dividir√© este archivo en 3 partes, una para cada parte del libro.

Enjoy :D

# Indice
- [Introducci√≥n](#introducci√≥n)
   * [Introducci√≥n a los Sistemas Operativos](#introducci√≥n-a-los-sistemas-operativos)
   * [Virtualizando la CPU](#virtualizando-la-cpu)
   * [Virtualizando la Memoria](#virtualizando-la-memoria)
   * [Concurrencia](#concurrencia)
    * [Persistencia](#persistencia)
    * [Desiciones de dise√±o](#desiciones-de-dise√±o)
    * [Un poco de historia](#un-poco-de-historia)
- [Virtualizaci√≥n](#virtualizacion)

# Introducci√≥n

 Las tres piezas f√°ciles se refieren a los tres elementos tem√°ticos principales en los que se organiza el libro: virtualizaci√≥n, concurrencia y persistencia. Al discutir estos conceptos, terminaremos hablando de la mayor√≠a de las cosas importantes que hace un sistema operativo; con suerte, tambi√©n se divertir√°n en el camino.

 - El primero es el `crux` del problema. Cada vez que tratamos de resolver un problema, primero intentamos declarar cu√°l es el tema m√°s importante; dicho crux del problema se se√±ala expl√≠citamente en el texto, y esperamos que se resuelva a trav√©s de las t√©cnicas, algoritmos e ideas presentadas en el resto del texto. 
 - En muchos lugares, explicaremos c√≥mo funciona un sistema mostrando su comportamiento a lo largo del tiempo. Estas l√≠neas de tiempo son la esencia de la comprensi√≥n; si sabes qu√© ocurre, estar√°s en camino a entender verdaderamente c√≥mo opera la memoria virtual. 
 
 - Si comprendes lo que sucede cuando un sistema de archivos con journaling escribe un bloque en el disco, habr√°s dado los primeros pasos hacia el dominio de los sistemas de almacenamiento.

 - Al principio de cada secci√≥n principal, primero presentaremos una `abstracci√≥n` que un sistema operativo proporciona, y luego trabajaremos en los cap√≠tulos siguientes sobre los mecanismos, pol√≠ticas y otros apoyos necesarios para proporcionar esa abstracci√≥n. 
    * Las abstracciones son fundamentales en todos los aspectos de la Ciencia de la Computaci√≥n, por lo que no es sorprendente que tambi√©n sean esenciales en los sistemas operativos.

> **Consejo**:  Asiste a clase, para escuchar al profesor presentar el material. Luego, al final de cada semana, lee estas notas, para ayudar a que las ideas se asienten un poco mejor en tu mente. Por supuesto, alg√∫n tiempo despu√©s (pista: antes del examen), vuelve a leer las notas para consolidar tu conocimiento. Por supuesto, tu profesor sin duda asignar√° algunas tareas y proyectos, as√≠ que deber√≠as hacerlos; en particular, hacer proyectos donde escribas c√≥digo real para resolver problemas reales es la mejor manera de poner en pr√°ctica las ideas de estas notas. 

## Introducci√≥n a los Sistemas Operativos

> **El CRUX del problema: C√≥mo virtualizar los recursos**: El porqu√© el sistema operativo hace esto no es la pregunta principal, ya que la respuesta deber√≠a ser obvia: hace que el sistema sea m√°s f√°cil de usar. Por lo tanto, nos enfocamos en el c√≥mo: ¬øqu√© mecanismos y pol√≠ticas implementa el sistema operativo para lograr la virtualizaci√≥n? ¬øC√≥mo lo hace de manera eficiente? ¬øQu√© soporte de hardware es necesario?

### Virtualizando la CPU

Si s√≥lo tenemos un procesador ¬øC√≥mo ocurre la magia de correr programas al mismo tiempo? Resulta que el sistema operativo, con algo de ayuda del hardware, es el encargado de crear esta ilusi√≥n, es decir, la ilusi√≥n de que el sistema tiene un n√∫mero muy grande de CPUs virtuales. Convertir un solo CPU (o un peque√±o conjunto de ellos) en un n√∫mero aparentemente infinito de CPUs y, por lo tanto, permitir que muchos programas se ejecuten aparentemente al mismo tiempo es lo que llamamos virtualizaci√≥n de la CPU.

Por supuesto, para ejecutar programas, detenerlos y, en general, indicarle al sistema operativo qu√© programas ejecutar, deben existir algunas interfaces (APIs) que puedes usar para comunicar tus deseos al sistema operativo. Hablaremos sobre estas APIs a lo largo del libro; de hecho, son la principal forma en que la mayor√≠a de los usuarios interact√∫a con los sistemas operativos.
    
### Virtualizando la Memoria

Ahora consideremos la memoria. El modelo de memoria f√≠sica presentado por las m√°quinas modernas es muy simple. La memoria es simplemente un array de bytes; para leer la memoria, se debe especificar una direcci√≥n para poder acceder a los datos almacenados all√≠; para escribir (o actualizar) memoria, tambi√©n se debe especificar los datos a escribir en la direcci√≥n dada.

La memoria se accede todo el tiempo cuando un programa est√° en ejecuci√≥n. Un programa mantiene todas sus estructuras de datos en memoria y accede a ellas mediante diversas instrucciones, como cargas y almacenamientos, o otras instrucciones expl√≠citas que acceden a la memoria para realizar su trabajo. No olvides que cada instrucci√≥n del programa tambi√©n est√° en memoria; por lo tanto, la memoria se accede en cada recuperaci√≥n de instrucci√≥n.

```C
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <sys/time.h>
#include <time.h>

void Spin(int seconds) {
    time_t start = time(NULL);
    while (time(NULL) - start < seconds) {
        // Bucle vac√≠o que consume tiempo
    }
}

int main(int argc, char *argv[]){
    int *p = malloc(sizeof(int)); // a1
    assert(p != NULL);
    printf("(%d) address pointed to by p: %p\n", getpid(), p); // a2
    *p = 0; // a3
    while (1) {
        Spin(1);
        *p = *p + 1;
        printf("(%d) p: %d\n", getpid(), *p); // a4
    }
    return 0;
}
```
El programa hace un par de cosas. Primero, asigna algo de memoria (l√≠nea a1). Luego, imprime la direcci√≥n de la memoria (a2) y, a continuaci√≥n, coloca el n√∫mero cero en la primera posici√≥n de la memoria reci√©n asignada (a3). Finalmente, entra en un bucle, retras√°ndose durante un segundo e incrementando el valor almacenado en la direcci√≥n contenida en p. Con cada declaraci√≥n de impresi√≥n, tambi√©n muestra lo que se llama el identificador del proceso (PID) del programa en ejecuci√≥n. Este PID es √∫nico para cada proceso en ejecuci√≥n. Nuevamente, este primer resultado no es muy interesante. La memoria reci√©n asignada est√° en la direcci√≥n 0x200000. A medida que el programa se ejecuta, actualiza lentamente el valor y muestra el resultado.

```bash
$ gcc -o mem mem.c
[1] 15998
(15999) address pointed to by p: 0x5b34db0ce2a0
(15998) address pointed to by p: 0x578a0f4c02a0
(15999) p: 1
(15998) p: 1
(15998) p: 2
(15999) p: 2
(15999) p: 3
(15998) p: 3
(15999) p: 4
(15998) p: 4
(15999) p: 5
(15998) p: 5
(15998) p: 6
(15999) p: 6
(15999) p: 7
(15998) p: 7
(15998) p: 8
(15999) p: 8
(15999) p: 9
(15998) p: 9

```

Ahora, ejecutamos varias instancias de este mismo programa para ver qu√© sucede (Figura 2.4). Vemos en el ejemplo que cada programa en ejecuci√≥n ha asignado memoria en la misma direcci√≥n (0x578a0f4c02a0), ¬°y sin embargo, cada uno parece estar actualizando el valor en 0x578a0f4c02a0 de forma independiente! Es como si cada programa en ejecuci√≥n tuviera su propia memoria privada, en lugar de compartir la misma memoria f√≠sica con otros programas en ejecuci√≥n. De hecho, eso es exactamente lo que est√° sucediendo aqu√≠, ya que el sistema operativo est√° virtualizando la memoria. Cada proceso accede a su propio espacio de direcciones virtuales privado (a veces simplemente llamado su espacio de direcciones), que el sistema operativo mapea de alguna manera a la memoria f√≠sica de la m√°quina. Una referencia de memoria dentro de un programa en ejecuci√≥n no afecta el espacio de direcciones de otros procesos (o del propio sistema operativo); en lo que respecta al programa en ejecuci√≥n, tiene la memoria f√≠sica solo para s√≠ mismo. La realidad, sin embargo, es que la memoria f√≠sica es un recurso compartido, gestionado por el sistema operativo. 

### Concurrencia

Usamos este t√©rmino conceptual para referirnos a una serie de problemas que surgen y deben ser abordados cuando se trabaja en muchas cosas al mismo tiempo (es decir, concurrentemente) en el mismo programa. Los problemas de concurrencia surgieron primero dentro del propio sistema operativo; como puedes ver en los ejemplos anteriores sobre virtualizaci√≥n, el sistema operativo est√° manejando muchas cosas a la vez, ejecutando primero un proceso, luego otro, y as√≠ sucesivamente. Resulta que hacer esto lleva a problemas profundos e interesantes

> El CRUX del problema:
Cuando hay muchos hilos ejecut√°ndose concurrentemente dentro del mismo espacio de memoria, ¬øc√≥mo podemos construir un programa que funcione correctamente? ¬øQu√© primitivas se necesitan del sistema operativo? ¬øQu√© mecanismos deben proporcionar el hardware? ¬øC√≥mo podemos usarlos para resolver los problemas de concurrencia?

### Persistencia

El tercer tema principal del curso es la persistencia. En la memoria del sistema, los datos pueden perderse f√°cilmente, ya que dispositivos como la DRAM almacenan valores de manera vol√°til; cuando se corta la energ√≠a o el sistema falla, cualquier dato en memoria se pierde. Por lo tanto, necesitamos hardware y software capaces de almacenar datos de manera persistente.

El software en el sistema operativo que generalmente gestiona el disco se llama el sistema de archivos; por lo tanto, es responsable de almacenar cualquier archivo que el usuario cree de manera confiable y eficiente en los discos del sistema.

A diferencia de las abstracciones proporcionadas por el sistema operativo para la CPU y la memoria, el sistema operativo no crea un disco virtualizado privado para cada aplicaci√≥n. M√°s bien, se asume que, a menudo, los usuarios querr√°n compartir informaci√≥n que est√° en archivos.

### Desiciones de dise√±o

Un objetivo en el dise√±o e implementaci√≥n de un sistema operativo es proporcionar un alto rendimiento; otra forma de decirlo es que nuestro objetivo es minimizar los sobrecostos del OS.

Otro objetivo ser√° proporcionar protecci√≥n entre aplicaciones, as√≠ como entre el OS y las aplicaciones. Debido a que queremos permitir que muchos programas se ejecuten al mismo tiempo, queremos asegurarnos de que el comportamiento malicioso o accidentalmente incorrecto de uno no da√±e a los dem√°s; ciertamente no queremos que una aplicaci√≥n pueda da√±ar el propio OS (ya que eso afectar√≠a a todos los programas que se ejecutan en el sistema). La protecci√≥n es el coraz√≥n de uno de los principales principios subyacentes de un sistema operativo, que es el de aislamiento; aislar procesos unos de otros es clave para la protecci√≥n y, por lo tanto, subyace en gran parte de lo que un OS debe hacer.

### Un poco de historia

#### Primeros Sistemas Operativos: Solo Bibliotecas

En sus inicios, los sistemas operativos (OS) eran bastante rudimentarios, funcionando esencialmente como bibliotecas de funciones comunes. En lugar de que cada programador escribiera c√≥digo para manejar I/O de bajo nivel, el "OS" proporcionaba APIs para facilitar el desarrollo. En estos sistemas de mainframe antiguos, solo se ejecutaba un programa a la vez, controlado por un operador humano. Mucho de lo que hoy consideramos funciones b√°sicas de un OS (como decidir el orden de ejecuci√≥n de trabajos) lo hac√≠a este operador. Este modo de procesamiento se conoc√≠a como procesamiento por lotes (batch processing), donde una serie de trabajos se configuraban y se ejecutaban en "lote" por el operador. Dado que era costoso permitir que un usuario interactuara directamente con la computadora, se utilizaba principalmente el procesamiento por lotes [BH00].

#### M√°s All√° de las Bibliotecas: Protecci√≥n

A medida que los sistemas operativos evolucionaron, asumieron un papel m√°s central en la gesti√≥n de las m√°quinas. Un aspecto importante fue reconocer que el c√≥digo ejecutado en nombre del OS deb√≠a ser especial y tratado de manera diferente al c√≥digo de aplicaci√≥n normal. Permitir que cualquier aplicaci√≥n leyera cualquier archivo en el disco compromet√≠a la privacidad. Por lo tanto, se invent√≥ la llamada a sistema (system call), un mecanismo que permiti√≥ la transici√≥n controlada al OS, elevando el nivel de privilegio del hardware. En contraste con una llamada a procedimiento, una llamada a sistema transfiere el control al OS mientras eleva el nivel de privilegio del hardware. Esto permiti√≥ al OS tener acceso completo al hardware y realizar operaciones como solicitudes de I/O o gestionar memoria. Una vez completada la solicitud, el control se devuelve al usuario.

#### La Era del Multiprogramming
Con la llegada de las minicomputadoras, los sistemas operativos dieron un gran salto. Las m√°quinas cl√°sicas como la PDP de Digital Equipment hicieron que las computadoras fueran m√°s asequibles, permitiendo que un grupo menor de personas dentro de una organizaci√≥n tuviera su propia m√°quina. Esto impuls√≥ la actividad de desarrollo y la innovaci√≥n en los sistemas operativos, especialmente con la multiprogramaci√≥n. En lugar de ejecutar un solo trabajo a la vez, el OS cargaba m√∫ltiples trabajos en memoria y cambiaba r√°pidamente entre ellos para mejorar la utilizaci√≥n del CPU. La necesidad de soportar multiprogramaci√≥n y la superposici√≥n en presencia de I/O e interrupciones llev√≥ a importantes innovaciones en la protecci√≥n de memoria y el manejo de la concurrencia. La introducci√≥n del sistema operativo UNIX por Ken Thompson y Dennis Ritchie en Bell Labs fue un avance significativo, al simplificar y hacer m√°s accesibles muchas ideas buenas de otros sistemas [O72, B+72, S68].

#### La Era Moderna
La llegada de las computadoras personales (PC) marc√≥ una nueva era en la inform√°tica. Las primeras PCs, como el Apple II y el IBM PC, se convirtieron en la fuerza dominante en la computaci√≥n debido a su bajo costo. Sin embargo, los primeros sistemas operativos de PC, como DOS, olvidaron o nunca aprendieron las lecciones de las minicomputadoras, como la protecci√≥n de memoria. Los primeros sistemas operativos de Mac (hasta la versi√≥n 9) ten√≠an un enfoque cooperativo para la programaci√≥n, lo que permit√≠a que un hilo atrapado en un bucle infinito pudiera tomar el control completo del sistema. Afortunadamente, con el tiempo, las caracter√≠sticas avanzadas de los sistemas operativos de minicomputadoras comenzaron a integrarse en los sistemas de escritorio. Hoy en d√≠a, sistemas como macOS, basado en UNIX, y Windows NT han adoptado muchas de las grandes ideas de la historia de la computaci√≥n. Incluso los tel√©fonos m√≥viles modernos, que ejecutan sistemas operativos como Linux, se asemejan m√°s a los sistemas de minicomputadoras de los a√±os 70 que a los PC de los a√±os 80. Es gratificante ver c√≥mo las buenas ideas del pasado contin√∫an evolucionando y mejorando los sistemas modernos.

#### ASIDE: La importancia de UNIX

Es dif√≠cil exagerar la importancia de UNIX en la historia de los sistemas operativos. Influenciado por sistemas anteriores, en particular el famoso sistema Multics del MIT, UNIX reuni√≥ muchas ideas innovadoras y cre√≥ un sistema tanto simple como poderoso. El principio unificador subyacente al UNIX original de "Bell Labs" era la construcci√≥n de peque√±os programas potentes que pod√≠an conectarse entre s√≠ para formar flujos de trabajo m√°s grandes. El shell, donde se escriben los comandos, proporcionaba primitivas como los pipes (tuber√≠as) para habilitar tal programaci√≥n a nivel meta, facilitando la conexi√≥n de programas para lograr una tarea m√°s compleja.

Por ejemplo, para encontrar l√≠neas en un archivo de texto que contengan la palabra "foo" y luego contar cu√°ntas de esas l√≠neas existen, se escribir√≠a: grep foo file.txt | wc -l, utilizando as√≠ los programas grep y wc (word count) para cumplir la tarea. El entorno UNIX era amigable tanto para programadores como para desarrolladores, proporcionando tambi√©n un compilador para el nuevo lenguaje de programaci√≥n C. Facilitar que los programadores escribieran sus propios programas, as√≠ como compartirlos, hizo que UNIX se volviera enormemente popular. Probablemente tambi√©n ayud√≥ mucho que los autores distribuyeran copias gratuitamente a quien las solicitara, una forma temprana de software de c√≥digo abierto.

Otra de las caracter√≠sticas cr√≠ticas fue la accesibilidad y legibilidad del c√≥digo. Tener un kernel hermoso y peque√±o escrito en C invitaba a otros a jugar con √©l, agregando nuevas y geniales funcionalidades. Por ejemplo, un grupo emprendedor en Berkeley, liderado por Bill Joy, cre√≥ una maravillosa distribuci√≥n (la Berkeley Systems Distribution, o BSD) que inclu√≠a subsistemas avanzados de memoria virtual, sistemas de archivos y redes. Joy luego cofund√≥ Sun Microsystems.

Desafortunadamente, la expansi√≥n de UNIX se vio un poco frenada cuando algunas empresas intentaron reclamar su propiedad y lucrar con √©l, un resultado desafortunado (pero com√∫n) cuando los abogados se involucran. Muchas empresas desarrollaron sus propias variantes: SunOS de Sun Microsystems, AIX de IBM, HPUX (conocido como "H-Pucks") de HP, e IRIX de SGI. Las disputas legales entre AT&T/Bell Labs y estos otros actores arrojaron una sombra sobre UNIX, y muchos se preguntaban si sobrevivir√≠a, especialmente con la introducci√≥n de Windows, que se apoder√≥ de gran parte del mercado de PCs...

#### ASIDE: Y luego lleg√≥ Linux

Afortunadamente para UNIX, un joven hacker finland√©s llamado Linus Torvalds decidi√≥ escribir su propia versi√≥n de UNIX, la cual se basaba en gran medida en los principios e ideas del sistema original, pero no en su base de c√≥digo, evitando as√≠ problemas legales. Torvalds cont√≥ con la ayuda de muchas personas de todo el mundo y aprovech√≥ las sofisticadas herramientas GNU que ya exist√≠an [G85], y pronto naci√≥ Linux (as√≠ como el movimiento moderno de software de c√≥digo abierto).

Con la llegada de la era de internet, la mayor√≠a de las empresas (como Google, Amazon, Facebook y otras) optaron por usar Linux, ya que era gratuito y pod√≠a modificarse f√°cilmente para satisfacer sus necesidades; de hecho, es dif√≠cil imaginar el √©xito de estas nuevas compa√±√≠as si un sistema as√≠ no hubiera existido. A medida que los tel√©fonos inteligentes se convirtieron en una plataforma dominante para los usuarios, Linux tambi√©n encontr√≥ un basti√≥n all√≠ (a trav√©s de Android), por muchas de las mismas razones. Adem√°s, Steve Jobs llev√≥ consigo su entorno operativo basado en UNIX, NeXTStep, a Apple, lo que hizo que UNIX fuera popular en los escritorios (aunque muchos usuarios de la tecnolog√≠a de Apple probablemente no sean conscientes de este hecho).

As√≠, UNIX sigue vivo, m√°s importante hoy que nunca. Los dioses de la computaci√≥n, si crees en ellos, deber√≠an ser agradecidos por este maravilloso resultado.









